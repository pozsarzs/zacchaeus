; +----------------------------------------------------------------------------+
; | PEMX External memory box (EPROM bank)                                      |
; | Copyright (C) 2025-2026 Pozsar Zsolt <pozsarzs@gmail.com>                  |
; | pemxapi.z80                                                                |
; | API of the PEMX equipment, Z80, CP/M-80, v0.1                              |
; +----------------------------------------------------------------------------+

PUBLIC PEMX

; --- PEMX API FUNCTION -----------------------------
; Input:     A = input data, optional
;            B = input data, optional
;            C = function code  (00-FFh)
;            DE = input data, optional
; Output:    Carry = 0, A = output data
;            Carry = 1, A = 0 (no valid return value)
; Preserves: BC, DE, HL
; Clobbers:  AF
;
; Z80PIO:
; Internal registers:
;   BA + 0: Port A data register
;   BA + 1: Port B data register
;   BA + 2: Port A control register
;   BA + 3: Port B control register
;
; Port A (output):
;   AD0-2: register selector demultiplexer input data
;   AD3:   write input data to selected register
;   AD4-7: register input data
; Port B (input):
;   BD0-7: output data from selected EPROM
;
; Using registers activated by register selector demultiplexer outputs:
;   -D0: nothing - default state
;   -D1: -E0 write data to EPROM selector demultiplexer (DS0-2)
;        -E0 enable output of the EPROM selector demultiplexer (DS3)
;   -D2: -E1 write data to address latch (A0-3)
;   -D3: -E2 write data to address latch (A4-7)
;   -D4: -E3 write data to address latch (A8-11)
;   -D5: -E4 write data to address latch (A12-15)
;   -D6: nothing
;   -D7: enable EPROM's -OE line

; --- API FUNCTION --------------------------

PEMX:				; ENTRY POINT
	PUSH	BC		; save BC register pair
	PUSH	DE		; save DE register pair
	PUSH	HL		; save HL register pair
	LD	H, A		; A -> H (i/o address, bank)
	LD	L, B		; B -> L (block)
	LD	A, C		; C -> A (function code)
	CP	00h		; subroutine selection
	JP	Z, F00		; - set I/O base address
	CP	01h
	JP	Z, F01		; - get I/O base address
	CP	02h
	JP	Z, F02		; - set 2 kB buffer mem. address
	CP	10h
	JP	Z, F10		; - read data from EPROM to buffer
	SCF			; - invalid function code, set Carry = 1

DONE:				; RETURN PROCESS
	POP	HL		; restore HL register pair
	POP	DE		; restore DE register pair
	POP	BC		; restore BC register pair
	RET	NC		; if Carry = 0 then return
	LD	A, 0		; - else A = 0
	SCF			;   set Carry flag
	RET

; --- SET I/O ADDRESS ------------------------
; Input:     A = function code  (00h)
;            H = i/o address    (00-FFh)
; Output:    Carry = 1 (no valid return value)
F00:
	LD	A, H		; H -> A
	LD	(IOAD), A	; store new i/o address
	SCF			; set Carry flag
	JP	DONE

; --- GET I/O ADDRESS ------------------
; Input:     A = function code  (01h)
; Output:    A = i/o address    (00-FFh)
;            Carry = 0
F01:
	LD	A, (IOAD)	; retrieve i/o address
	AND	A		; reset Carry flag
	JP	DONE

; --- Set 2 kB buffer start address. ------------------------
; Input:     A = function code   (02h)
;            DE = memory address (0000-FFFFh)
; Output:    Carry = 1 (no valid return value)
F02:
	LD	(BUAD), DE	; store new i/o address
	SCF			; set Carry flag
	JP	DONE

; -- Read 2048 byte data (1 page) from EPROM to buffer ----
; Input:     A = function code     (10h)
;            H = EPROM bank number (0-7h)
;            L = EPROM page index  (0-1Fh)
; Output:    A = 0, Carry = 0: no error
;            A = 1, Carry = 0: no Z80PIO on the specified port
;            A = 4, Carry = 0: invalid 'bank' value
;            A = 8, Carry = 0: invalid 'page' value
 
F10:
	LD	A, H		; H -> A
	LD	(EPBI), H	; store EPROM bank index
	LD	A, L		; L -> A
	LD	(EPPI), L	; store EPROM page index

				; CHECK BANK AND PAGE INDEX
	LD	A, H		; H -> A
	CP	08h		; check value of the bank index (0..7)
	JP	NC, ERBI	; if (EPBI) => 8 then goto label ERBI
	LD	A, L		; H -> A
	CP	20h		; check value of the page index (0..31)
	JP	NC, ERPI	; if (EPPI) => 32 then goto label ERPI

				; ZEROIZE BUFFER AND VARIABLE(S)			
	XOR	A		; 0 -> A
	LD	HL, 0		; 0 -> HL
	LD	(EPAD), HL	; reset (EPAD) variable
	LD	HL, (BUAD)	; buffer address -> HL
	LD	(HL), A		; reset value of the (BUAD)
	LD	D, H            ; H -> D
    	LD	E, L		; L -> E
	INC	DE		; increment DE
	LD	BC, (BUSI)	; 2047 -> BC
	LDIR			; reset (BUAD)...(BUAD) + 2047 area

				; INITIALIZE Z80PIO
	LD	A, (IOAD)	; i/o address -> A
	ADD	A, 2		; A = A + 2 (Port A control register)
	LD	C, A		; A -> C
	LD	A, 0Fh		; set port A to output mode 
	LD	B, 0		; 0 -> B
	OUT	(C), A		; write control byte to PIO register
	IN	B, (C)		; read control register to check PIO
	CP	B		; compare input and output data
	JP	NZ, ERIO	; if not equal goto label ERIO
	INC	C		; A = A + 1 (Port B control register)
	LD	A, 4Fh		; set port B to input mode 
	LD	B, 0		; 0 -> B
	OUT	(C), A		; write control byte to PIO resister

				; STORE EPROM BANK NUMBER
	LD	A, (EPBI)	; EPROM bank number -> A
	AND	07h		; A = 0000 0nnnb, nnn: 0..7 bank number
	OR	08h		; A = 0000 1nnnb, bit3: enable demux (U9) output
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left, A = 1nnn 0000b
	OR	01h		; A = 1nnn 0001b, bit0: select bank register (U5)
	CALL	RGWR		; write data to register

LOOP:				; TOP OF THE READING LOOP

				; MAKE PHYSICAL ADDRESS
	LD	BC, (EPAD)	; 0000 0aaa aaaa aaaab
	LD	A, (EPPI)	; ???p ppppb
	AND	1Fh		; 000p ppppb
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left, pppp p000b
	OR	B		; pppp paaab (BC: pppp paaa aaaa aaaa)
	LD	B, A		; A -> B

				; STORE LOW BYTE-LOW NIBBLE OF THE EPROM ADDRESS
	LD	A, C		; A = nnnn nnnn
	AND	0Fh		; A = 0000 nnnn b
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; A = nnnn 0000 b
	OR	02h		; A = nnnn 0010 b
	CALL	RGWR

				; STORE LOW BYTE-HIGH NIBBLE OF THE EPROM ADDRESS
	LD	A, C		; A = nnnn nnnn
	AND	0F0h		; A = nnnn 0000 b
	OR	03h		; A = nnnn 0011 b
	CALL	RGWR

				; STORE HIGH BYTE-LOW NIBBLE OF THE EPROM ADDRESS
	LD	A, B		; A = nnnn nnnn
	AND	0Fh		; A = 0000 nnnn b
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; rotate bits to left
	RLCA			; A = nnnn 0000 b
	OR	04h		; A = nnnn 0100 b
	CALL	RGWR		; write data to a register

				; STORE HIGH BYTE-HIGH NIBBLE OF THE EPROM ADDRESS
	LD	A, B		; A = nnnn nnnn
	AND	0F0h		; A = nnnn 0000 b
	OR	05h		; A = nnnn 0101 b
	CALL	RGWR		; 

				; READ A BYTE FROM EPROM,
	CALL	RGRD		; A = byte from EPROM

				; STORE A BYTE
	LD	HL, (BUAD)	; buffer address -> HL
	LD	DE, (EPAD)	; offset -> DE
	ADD	HL, DE		; HL = buffer address + offset
	LD	(HL), A		; read byte -> (HL)

				; INCREMENT OFFSET
	INC	DE		; increment DE
	LD	(EPAD), DE	; incremented offset -> (EPAD)
	LD	HL, (EPAD)	; (EPAD) -> HL
	LD	BC, 2048	; 2048 -> BC
	OR	A          	; reset CF
	SBC	HL, BC		; subtract 2048 from
	JP	C, LOOP		; if HL < 2048 then goto loop label
				; BOTTOM OF THE READING LOOP

CLOSE:				; SET Z80PIO TO DEFAULT MODE
	LD	A, (IOAD)	; i/o address -> A
	ADD	A, 2		; A = A + 2 (Port A control register)
	LD	C, A		; A -> C
	LD	A, 4Fh		; set port A to input mode 
	OUT	(C), A		; write control byte to PIO resister
	INC	C		; A = A + 1 (Port B control register)
	LD	A, 4Fh		; set port B to input mode 
	OUT	(C), A		; write control byte to PIO resister
	XOR	A          	; reset A and CF
	JP	DONE

ERIO:				; NO Z80PIO ON THE SPECIFIED PORT
	LD	A, 01h		; set return value to 1
	XOR	A          	; reset A and CF
	JP	DONE

ERBI:				; INVALID 'BANK' VALUE
	LD	A, 02h		; set return value to 2
	XOR	A          	; reset A and CF
	JP	DONE

ERPI:				; INVALID 'PAGE' VALUE
	LD	A, 04h		; set return value to 4
	XOR	A          	; reset A and CF

	JP	DONE		; RETURN
	
RGWR:				; WRITE DATA TO ONE OF THE REGISTERS
	PUSH	BC		; save BC registers
	PUSH	DE		; save DE registers
	LD	B, A		; A -> B
	LD	A, (IOAD)	; i/o address -> A
	LD	C, A		; A -> C
	LD	A, B		; B -> A
	LD	B, 0		; 0 -> B
	OR	8		; set to 1 the CLK line, A = 1nnn 1001 b
	OUT	(C), A		; write to port
	NOP			; waiting
	NOP			; waiting
	AND     0F7h		; set to 0 the CLK line, A = 1nnn 0001 b
	OUT	(C), A		; write to port
	POP	DE		; restore DE register pair
	POP	BC		; restore BC register pair
	RET

RGRD:				; READ DATA AND STORE IN THE BUFFER
	PUSH	BC		; save BC register pair
	NOP			; waiting
	NOP			; waiting
	LD	B, 0		; 0 -> B
	LD	A, (IOAD)	; i/o address -> A
	LD	C, A		; A -> C
	INC	C		; set B port address
	IN	A, (C)		; read a byte	
	POP	BC		; restore BC register pair
	RET

; --- DATA AREA ------------------------------------------------
BUAD:	DW	0		; buffer start address
BUSI:	DW	2047		; buffer size in byte - 1
EPAD:	DW	0		; recent EPROM address (0..2047)
EPBI:	DB	0		; selected EPROM bank index
EPPI:	DB	0		; selected EPROM page index
IOAD:	DB	0		; I/O port base address (Z80PIO)
	END

