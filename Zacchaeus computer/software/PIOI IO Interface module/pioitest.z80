; +----------------------------------------------------------------------------+
; | Zacchaeus Microcomputer                                                    |
; | Pozsar Zsolt <pozsarzs@gmail.com>, 2025. CC0 1.0 Universal                 |
; | pioitest.z80                                                               |
; | Tester program for PIOI interface module for CP/M-80                       |
; +----------------------------------------------------------------------------+

; I/O ports: * Protected inputs
;              -PI0: D0 and D1 bits (equal and inverted)
;              -PI1: D2 and D3 bits (equal and inverted)
;              -PI2: D4 and D5 bits (equal and inverted)
;              -PI3: D6 and D7 bits (equal and inverted)
;            * Open collector outputs
;              OCO0: D0 bit
;              OCO1: D1 bit
;              OCO2: D2 bit
;              OCO3: D3 bit
;            * Relay contact outputs
;              RCO0: D4 bit
;              RCO1: D5 bit
;              RCO2: D6 bit
;              RCO3: D7 bit

	ORG	100h
BDOS	EQU	005h			; BDOS system call

START:	LD	DE, MSG01		; show header 
	CALL	WRITE
	LD	DE, MSG02	   	
	CALL	WRITE
MENU:	LD	DE, MSG03		; show menu 
	CALL	WRITE
CHOICE:	LD	DE, MSG04		; show menu prompt
	CALL	WRITE 
	LD	C, 1			; read a character
	CALL	BDOS
	CP	'1'			; evaluation
	JP	Z, PROC_1
	CP	'2'
	JP	Z, PROC_2
	CP	'3'
	JP	Z, PROC_3
	CP	'4'
	JP	Z, PROC_4
	CP	'q'
	JP	Z, QUIT
	LD	DE, MSG05		; bad choice
	CALL	WRITE
	JP	CHOICE 

PROC_1:
	LD	DE, MSG06		; set I/O address
	CALL	WRITE
	LD	DE, MSG04
	XOR	A			; erase variables
	LD	(BA), A
	LD	(DIGCNT), A
READ_1:	CALL	GETCHR			; read a character
	LD	(CH1), A		; store in ASCII code
	CALL	HEX2BIN			; convert to byte value
	JP	C, READ_1		; if it a 'bad' char, read a new one
	LD	B,A			; increment number of digits
	LD	A,(DIGCNT)
	INC	A
	LD	(DIGCNT),A
	CP	2			; if it the 2nd digit go to other storing method
	JP	Z, ST2ND
	LD	A, (CH1)		; store in ASCII code
	LD	(CH0),A
	LD	A, B			; multiplicate with 16
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	LD	(BA), A			; store (higher half-byte)
	JP	READ_1			; new read for 2nd digit
ST2ND:	LD	A, (BA)			; add lower half-byte to higher
	OR	B
	LD	(BA), A			; store base address
DONE_1:	LD	DE, MSG09		; done is value entering
	CALL	WRITE			; show base address
	LD	A, (CH0)
	LD	E, A
	CALL	PUTCHR 
	LD	A, (CH1)
	LD	E, A 
	CALL	PUTCHR 
	LD	DE, NL
	CALL	WRITE 
	JP	MENU 

PROC_2:					; read protected inputs (PI 0..3)
	LD	DE, MSG07
	CALL	WRITE
LOOP_2:	LD	B, 255			; delay
WAIT_2:	NOP
	NOP
	NOP
	NOP
	DJNZ	WAIT_2
	LD	DE, CR			; carriage return
	CALL	WRITE
	LD	C, 1			; read a character
	CALL	BDOS
	CP	' '			; 'space' -> read port
	JP	Z, GETP_2
	CP	'q'			; 'q' -> exit to menu 
	JP	Z, MENU
	JP	LOOP_2 
GETP_2:	LD	A, (BA)			; read port
	LD	C, A 
	IN	A, (C)
	XOR	255
	LD	B, A
BIT76:	AND	3			; state of PI 0
	CP	3
	JP	Z, HIGH_1
	LD	DE, LOW
	PUSH	BC
	CALL	WRITE
	JP	BIT54
HIGH_1:	LD	DE, HIGH
	CALL	WRITE
BIT54:	POP	BC			; state of PI 1
	LD	A, B	
	AND	12
	CP	12
	JP	Z, HIGH_2
	LD	DE, LOW
	PUSH	BC
	CALL	WRITE
	JP	BIT32
HIGH_2:	LD	DE, HIGH
	CALL	WRITE
BIT32:	POP	BC			; state of PI 2
	LD	A, B
	AND	48
	CP	48
	JP	Z, HIGH_3
	LD	DE, LOW
	PUSH	BC
	CALL	WRITE
	JP	BIT10
HIGH_3:	LD	DE, HIGH
	CALL	WRITE
BIT10:	POP	BC			; state of PI 3
	LD	A, B	
	AND	192
	CP	192
	JP	Z, HIGH_4
	LD	DE, LOW
	CALL	WRITE
	JP	DONE_2
HIGH_4:	LD	DE, HIGH
	CALL	WRITE
DONE_2:	LD	DE, CR
	CALL	WRITE
	LD	DE, LF
	CALL	WRITE
JP	LOOP_2

PROC_3:;				set open collector outputs (OCO 0..3)
	LD	DE, MSG08
	CALL	WRITE
LOOP_3:	LD	B, 255
WAIT_3:	NOP				; delay
	NOP
	NOP
	NOP
	DJNZ	WAIT_3
	LD	DE, CR			; carriage return
	CALL	WRITE
	LD	C, 1			; read a character
	CALL	BDOS
	CP	'0'			; evaluation
	JP	Z, SET_31
	CP	'1'
	JP	Z, SET_32
	CP	'2'
	JP	Z, SET_33
	CP	'3'
	JP	Z, SET_34
	CP	'q'
	JP	Z, RST
	JP	LOOP_3 
SET_31:	LD	D, 01h			; set/reset OCO 0
	CALL	SETP
	JP	LOOP_3
SET_32:	LD	D, 02h			; set/reset OCO 1
	CALL	SETP
	JP	LOOP_3
SET_33:	LD	D, 04h			; set/reset OCO 2
	CALL	SETP
	JP	LOOP_3
SET_34:	LD	D, 08h			; set/reset OCO 3
	CALL	SETP
	JP	LOOP_3


PROC_4:
	LD	DE, MSG08		; set relay contact outputs (RCO 0..3)
	CALL	WRITE
LOOP_4:	LD	B, 255
WAIT_4:	NOP				; delay
	NOP
	NOP
	NOP
	DJNZ	WAIT_4
	LD	DE, CR			; carriage return
	CALL	WRITE
	LD	C, 1			; read a character
	CALL	BDOS
	CP	'0'			; evaluation
	JP	Z, SET_41
	CP	'1'
	JP	Z, SET_42
	CP	'2'
	JP	Z, SET_43
	CP	'3'
	JP	Z, SET_44		; set/reset RCO 3
	CP	'q'
	JP	Z, RST
	JP	LOOP_4 
SET_41:	LD	D, 10h			; set/reset RCO  
	CALL	SETP
	JP	LOOP_4
SET_42:	LD	D, 20h			; set/reset RCO 1
	CALL	SETP
	JP	LOOP_4
SET_43:	LD	D, 40h			; set/reset RCO 2
	CALL	SETP
	JP	LOOP_4
SET_44:	LD	D, 80h			; set/reset RCO 3
	CALL	SETP
	JP	LOOP_4

RST:					; reset all ports
	CALL	RESETP
	JP	MENU

QUIT:
	CALL	RESETP			; exit from program
	LD	C, 0
	CALL	BDOS
	RET

; *** SET PORT AND STORE OUTPUT DATA ***
; Input:     D = select port
; Output:    -
; Preserves: BC, DE
; Clobbers:  AF
SETP:
	PUSH	BC
	PUSH	DE
	LD	A, (BA)
	LD	C, A
	LD	A, (OD)
	XOR	D
	LD	(OD), A
	OUT	(C), A
	POP	DE
	POP	BC
	RET

; --- RESET ALL PORTS AND STORE OUTPUT DATA ---
; Input:     -
; Outputs:   -
; Preserves: BC
; Clobbers:  AF
RESETP:
	PUSH	BC
	LD	A, (BA)
	LD	C, A
	LD	A, 0
	OUT	(C), A
	LD	(OD), A
	POP	BC
	RET

; --- ASCII HEX -> BIN (0..15) CONVERSION ---
; Input:    A = character (ASCII code)
; Output:   A = character (ASCII code)
;           Carry = 1: error
; Clobbers:  AF
HEX2BIN:
	CP	'0'			; input character: 0..9
	JP	C, BAD
	CP	'9'+1
	JP	C, NUM

	CP	'A'			; input character: A..F
	JP	C, BAD
	CP	'F'+1
	JP	C, BIG

	CP	'a'			; input character: a..f
	JP	C, BAD
	CP	'f'+1
	JP	NC, BAD

	SUB	'a'-10
	OR	A
	RET

BIG:	SUB	'A'-10
	OR	A
	RET

NUM:	SUB	'0'
	OR	A
	RET

BAD:	SCF				; input character is bad
	RET

; --- READ A CHARACTER FROM CONSOLE ---
; Output:    A = character (ASCII code)
; Preserves: BC
GETCHR:
	PUSH	BC
	LD	C, 1
	CALL	BDOS
	POP	BC
	RET

; --- WRITE A CHARACTER TO CONSOLE ----
; Input:     E = character (ASCII code)
; Preserves: BC
PUTCHR:
	PUSH	BC
	LD	C, 2
	CALL	BDOS
	POP	BC
	RET

; --- WRITE MESSAGE TO CONSOLE -----------------
; Input:     DE = starting address of the string
; Preserves: BC
WRITE:
	PUSH	BC
	LD	C, 9
	CALL	BDOS
	POP	BC
	RET

; --- DATA AREA ---------------------------------------------------------------------------------
BA:	DB	0Ch			; base address
CH0	DB	32			; input value in ASCII
CH1	DB	32			; input value in ASCII
CR:	DB	0Dh, '$'		; carriage return
DIGCNT:	DB	0			; digit number of input value
HIGH:	DB	' 1$'			; high state
LF:	DB	0Ah, '$'		; line feed
LOW:	DB	' 0$'			; low state
NL:	DB	0Dh, 0Ah, '$'		; new line
OD:	DB	0			; output data
; messages
MSG01:	DB   	'*** PIOI module tester for Zacchaeus Microcomputer ***', 0Dh, 0Ah, '$'
MSG02:	DB   	'(C) 2025 Pozsar Zsolt <pozsarzs@gmail.com> CC0 1.0 Universal$'
MSG03:	DB   	0Dh, 0Ah,'------------------------------------------------------------', 0Dh, 0Ah
	DB   	' 1: set address', 0Dh, 0Ah
	DB   	' 2: read input', 0Dh, 0Ah
	DB   	' 3: set open collector outputs', 0Dh, 0Ah
	DB   	' 4: set relay contact outputs', 0Dh, 0Ah
	DB  	' q: quit', 0Dh, 0Ah
	DB   	'------------------------------------------------------------$'
MSG04:	DB   	0Dh, 0Ah,'> $'
MSG05:	DB	' - No such item, enter again!$'
MSG06:	DB	0Dh, 0Ah, 'Enter i/o address in hexadecimal format:$'
MSG07:	DB	0Dh, 0Ah, 'Use [ ] to read and [q] to exit.', 0Dh, 0Ah, '$'
MSG08:	DB	0Dh, 0Ah, 'Use [0][1][2][3] to toggle output and [q] to exit.', 0Dh, 0Ah, '$'
MSG09:	DB	0Dh, 0Ah, 'Result: $'
	END
