; +----------------------------------------------------------------------------+
; | Zacchaeus Microcomputer                                                    |
; | Pozsar Zsolt <pozsarzs@gmail.com>, 2025. CC0 1.0 Universal                 |
; | pioiapi.z80                                                                |
; | API of the PIOI interface for CP/M-80                                      |
; +----------------------------------------------------------------------------+

PUBLIC PIOI

; --- PIOI API FUNCTION -----------------------------
; Input:     A = input data, optional
;            B = input data, optional
;            C = function code  (00-FFh)
; Output:    Carry = 0, A = output data
;            Carry = 1, A = 0 (no valid return value)
; Preserves: BC, DE, HL
; Clobbers:  AF
;
; I/O ports: * Protected inputs
;              -PI0: D0 and D1 bits (equal and inverted)
;              -PI1: D2 and D3 bits (equal and inverted)
;              -PI2: D4 and D5 bits (equal and inverted)
;              -PI3: D6 and D7 bits (equal and inverted)
;            * Open collector outputs
;              OCO0: D0 bit
;              OCO1: D1 bit
;              OCO2: D2 bit
;              OCO3: D3 bit
;            * Relay contact outputs
;              RCO0: D4 bit
;              RCO1: D5 bit
;              RCO2: D6 bit
;              RCO3: D7 bit

PIOI:
	PUSH	BC		; enter and save registers
	PUSH	DE
	PUSH	HL
	LD	D, A		; A -> D (address, data)
	LD	E, B		; B -> E (port number, mask) 
	LD	A, C		; C -> A (function code)

	CP	00h		; subroutine selection
	JP	Z, F00		; - set address
	CP	01h
	JP	Z, F01		; - get address
	CP	02h
	JP	Z, F02		; - reset all OCOs and RCOs
	CP	03h
	JP	Z, F03		; - reset all OCOs
	CP	04h
	JP	Z, F04		; - reset all RCOs
	CP	10h
	JP	Z, F10		; - read data from all pis
	CP	11h
	JP	Z, F10		; - masked read data from all pis
	CP	12h
	JP	Z, F12		; - masked change checking of all pis
	CP	18h
	JP	Z, F18		; - read state from a PI
	CP	20h
	JP	Z, F20		; - write data to all OCOs
	CP	21h
	JP	Z, F21		; - masked write data to all OCOs
	CP	28h
	JP	Z, F28		; - switch on a OCO port
	CP	29h
	JP	Z, F29		; - switch off a OCO port
	CP	2Ah
	JP	Z, F2A		; - switch on and delayed off a OCO port
	CP	30h
	JP	Z, F30		; - write data to all RCOs
	CP	31h
	JP	Z, F31		; - masked write data to all RCOs
	CP	38h
	JP	Z, F38		; - switch on a RCO port
	CP	39h
	JP	Z, F39		; - switch off a RCO port
	CP	3Ah
	JP	Z, F3A		; - switch on and delayed off a RCO port
	SCF			; - invalid function code, set Carry = 1
	JR	DONE

DONE:
	POP	HL		; restore registers and return
	POP	DE
	POP	BC
	RET	NC		; if Carry = 0 then return
	LD	A, 0		; - else A = 0
	SCF			;   set Carry flag
	RET

; --- SET ADDRESS ----------------------------
; Input:     A = function code  (00h)
;            D = i/o address    (00-FFh)
; Output:    Carry = 1 (no valid return value)
F00:
	LD	A, D		; D -> A
	LD	(ADDR), A	; store new i/o address
	SCF			; set Carry flag
	JP	DONE

; --- GET ADDRESS ---------------------
; Input:     A = function code  (01h)
; Output:    A = i/o address    (00-FFh)
;            Carry = 0
F01:
	LD	A, (ADDR)	; retrieve i/o address
	AND	A		; reset Carry flag
	JP	DONE

; --- RESET ALL OCOS AND RCOS ----------------
; Input:     A = function code  (02h)
; Output:    Carry = 1 (no valid return value)
F02:
	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, 0		; set output data
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write output data to port
	SCF			; set Carry flag
	JP	DONE

; --- RESET ALL OCOS -------------------------
; Input:     A = function code  (03h)
; Output:    Carry = 1 (no valid return value)
F03:
	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	LD	B, 0F0h		; set mask
	AND	B		; merge bytes
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write output data to port
	SCF			; set Carry flag
	JP	DONE

; --- RESET ALL RCOS -------------------------
; Input:     A = function code  (04h)
; Output:    Carry = 1 (no valid return value)
F04:
	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	LD	B, 0Fh		; set mask
	AND	B		; merge bytes
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write output data to port
	SCF			; set Carry flag
	JP	DONE

; --- (MASKED) READ DATA FROM ALL PIS --------------
; Input:     A = function code  (10-11h)
;            E = mask           (00-0Fh), if A = 11h
; Output:    A = input data     (00-0Fh)
;            Carry = 0
F10:
	LD	H, A		; A -> H
	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	IN	A, (C)		; read input data from port
	XOR	0FFh		; invert input data
	LD	(DATINP), A	; store input data (in DDCCBBAA format)

	AND	01h		; detect state of 0th bit
	LD	D, A		; store partial result

	LD	A, (DATINP)	; retrieve input data
	AND	04h		; detect state of 2nd bit
	SRL	A		; shift left
	OR	D		; add to partial result
	LD	D, A		; store partial result

	LD	A, (DATINP)	; retrieve input data
	AND	10h		; detect state of 4th bit
	SRL	A		; shift left
	SRL	A
	OR	D		; add to partial result
	LD	D, A		; store partial result

	LD	A, (DATINP)	; retrieve input data
	AND	40h		; detect state of 6th bit
	SRL	A		; shift left
	SRL	A
	SRL	A
	OR	D		; add to partial result
	LD	(DATINP), A	; store input data (in 0000DCBA format)

	LD	A, H		; H -> A
	CP	11h		; if function code is 11h,
	JP	Z, _F11		; - then jump to _F11 label
	LD	A, (DATINP)	; - else retrieve input data
	AND	A		;   reset Carry flag
	JP	DONE

_F11:
	LD	A, (DATINP)	; retrieve input data
	AND	E		; mask input data
	AND	0Fh		; remove upper bits
	AND	A		; reset Carry flag
	JP	DONE

; --- MASKED CHANGE CHECKING OF ALL PIS ---
; Input:     A = function code  (12h)
;            D = save?          (00/FFh)
;            E = mask           (00-0Fh)
; Output:    A = changed?       (00/FFh)
;            Carry = 0
F12:
	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	IN	A, (C)		; read input data from port
	XOR	0FFh		; invert input data
	LD	H, A		; store input data (in DDCCBBAA format)

	AND	01h		; detect state of 0th bit
	LD	B, A		; store partial result

	LD	A, H		; retrieve input data
	AND	04h		; detect state of 2nd bit
	SRL	A		; shift left
	OR	B		; add to partial result
	LD	B, A		; store partial result

	LD	A, H		; retrieve input data
	AND	10h		; detect state of 4th bit
	SRL	A		; shift left
	SRL	A
	OR	B		; add to partial result
	LD	B, A		; store partial result

	LD	A, H		; retrieve input data
	AND	40h		; detect state of 6th bit
	SRL	A		; shift left
	SRL	A
	SRL	A
	OR	B		; add to partial result
	LD	H, A		; store input data

	LD	A, H		; retrieve input data
	AND	E		; mask input data
	LD	B, A		; store masked input data
	LD	A, (DATINP)	; retrieve previous input data
	AND	E		; mask previous input data
	CP	B		; compare recent and previous data
	JP	NZ, _CH12	; if not equal then goto label _CH12

	CALL	_SV12		; - else store input data (in 0000DCBA format)
	LD	A, 0		;   -> data is not changed 
	AND	A		;   reset Carry flag
	JP	DONE

_CH12:
	CALL	_SV12		; store input data (in 0000DCBA format)
	LD	A, 0FFh		; -> data is changed   
	AND	A		; reset Carry flag
	JP	DONE

_SV12:
	PUSH	AF		; save registers
	LD	A, D		; D -> A
	CP	A, 0		; if A = 0 then
	RET	Z		; - return
	LD	A, H		; - else retrieve input data
	LD	(DATINP), A	;   store input data (in 0000DCBA format)
	POP	AF		; store registers
	RET

; --- READ STATE FROM A PI -------------
; Input:     A = function code  (18h)
;            E = port number    (00-03h)
; Output:    A = state          (00/FFh)
;            Carry = 0
F18:
	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	IN	A, (C)		; read input data from port
	XOR	0FFh		; invert input data
	LD	(DATINP), A	; store input data (in DDCCBBAA format)

	AND	01h		; detect state of 0th bit
	LD	D, A		; store partial result

	LD	A, (DATINP)	; retrieve input data
	AND	04h		; detect state of 2nd bit
	SRL	A		; shift left
	OR	D		; add to result
	LD	D, A		; store partial result

	LD	A, (DATINP)	; retrieve input data
	AND	10h		; detect state of 4th bit
	SRL	A		; shift left
	SRL	A
	OR	D		; add to result
	LD	D, A		; store partial result

	LD	A, (DATINP)	; retrieve input data
	AND	40h		; detect state of 6th bit
	SRL	A		; shift left
	SRL	A
	SRL	A
	OR	D		; add to result
	LD	(DATINP), A	; store input data (in 0000DCBA format)

	INC	E		; increment port number
_LO18:
	DEC	E		; decrement port number, E = 0 -> Z = 0
	JP	Z, _DO18	; if Z = 0 then goto _DO18 label					
	SRL	A		; - else shift to right
	JP	_LO18		;   goto _L018 label     
_DO18:
	AND	01h		; mask result
	JR	Z, _ZE18	; if the result is 0 then goto _ZE18
	LD	A, 0FFh		; - else true output state
	AND	A		;   reset Carry flag
	JP	DONE
 _ZE18:	XOR	A		; set A = 0 and reset Carry flag
	JP	DONE

; --- WRITE DATA TO ALL OCOS -----------------
; Input:     A = function code  (20h)
;            D = output data    (00-0Fh)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F20:
	LD	A, D		; D -> A
	AND	0Fh		; mask output data
	LD      D, A		; masked output data -> D

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; i/o address -> C

	LD	A, (DATOUT)	; retrieve previous output data
	AND	0F0h		; mask previous output data
	OR	D		; merge bytes
	LD	(DATOUT), A	; store data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- MASKED WRITE DATA TO ALL OCOS ----------
; Input:     A = function code  (21h)
;            D = output data    (00-0Fh)
;            E = mask           (00-0Fh)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F21:
	LD	A, E		; E -> A
	AND	0Fh		; mask the mask
	LD	E, A		; A -> E

	LD	A, D		; D -> A
	AND	0Fh		; mask output data
	AND	E		; mask output data	
	LD      D, A		; masked output data -> D

	LD	A, E		; E -> A
	XOR	0FFh		; invert mask
	OR	0F0h		; protect high 4 bits
	LD	E, A		; A -> E

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; i/o address -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; mask previous output data
	OR	D		; merge bytes
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- SWITCH ON A OCO PORT ------------------------------------------------------
; Input:     A = function code  (28h)
;            E = port number    (00-03h)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F28:
	LD	A, 1		; starting place value
	LD	B, E		; E -> B, shift counter
	INC	B		; correction
    
_LO28:
	DEC	B		; if B = 0
	JR	Z, _DO28	; - the goto _DO28 label
	SLA	A		; - else shift to left
    	JR	_LO28		;   goto _LO28 label

_DO28:
	AND	0Fh		; mask the place value
	LD	D, A		; A -> D

	XOR	0FFh		; invert place value
	OR	0F0h		; protect upper 4 bits
	LD	E, A		; A -> E (byte punch mask)

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; punch specified place valC)
	OR	D		; put 1 to hole
	
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- SWITCH OFF A OCO PORT ------------------
; Input:     A = function code  (29h)
;            E = port number    (00-03h)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F29:
	LD	A, 1		; starting place value
	LD	B, E		; E -> B, shift counter
	INC	B		; correction
    
_LO29:
	DEC	B		; if B = 0
	JR	Z, _DO29	; - the goto _DO29 label
	SLA	A		; - else shift to left
    	JR	_LO29		;   goto _LO29 label

_DO29:
	AND	0Fh		; mask the place value
	LD	D, A		; A -> D

	XOR	0FFh		; invert place value
	OR	0F0h		; protect upper 4 bits
	LD	E, A		; A -> E (byte punch mask)

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; punch specified place valC)
	
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- SWITCH ON AND DELAYED OFF A OCO PORT ---
; Input:     A = function code  (2Ah)
;            D = relative delay (00-FFh)
;            E = port number    (00-03h)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F2A:
	LD	A, 1		; starting place value
	LD	B, E		; E -> B, shift counter
	INC	B		; correction
    
_LO2A:
	DEC	B		; if B = 0
	JR	Z, _DO2A	; - the goto _DO2A label
	SLA	A		; - else shift to left
    	JR	_LO2A		;   goto _LO2A label

_DO2A:
	AND	0Fh		; mask the place value
	LD	H, A		; A -> H

	XOR	0FFh		; invert place value
	OR	0F0h		; protect upper 4 bits
	LD	E, A		; A -> E (byte punch mask)

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; punch specified place valC)
	OR	H		; put 1 to hole
	OUT	(C), A		; write out data

	PUSH	HL		; save registers
_OL2A:				; start of the outer loop
	LD	HL, 4000h	; inner loop counter
_IL2A:				; start of the inner loop
	NOP			; waste of time
	DEC	HL		; decrement counter
	LD	A, H		; H -> A
	OR	L		; if H OR L = 0 -> Z = 1
	JP	NZ, _IL2A	; end of the inner loop
	DEC	D		; decrement relative delay value
	JP	NZ, _OL2A	; end of the outer loop
	POP	HL		; restore registers

	LD	A, (DATOUT)	; retrieve previous output data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- WRITE DATA TO ALL RCOS -----------------
; Input:     A = function code  (30h)
;            D = output data    (00-0Fh)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F30:
	LD	A, D		; D -> A
	AND	0F0h		; mask output data
	LD      D, A		; masked output data -> D

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; i/o address -> C

	LD	A, (DATOUT)	; retrieve previous output data
	AND	0Fh		; mask previous output data
	OR	D		; merge bytes
	LD	(DATOUT), A	; store data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- MASKED WRITE DATA TO ALL RCOS ----------
; Input:     A = function code  (31h)
;            D = output data    (00-0Fh)
;            E = mask           (00-0Fh)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F31:
	LD	A, E		; E -> A
	AND	0Fh		; mask the mask
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	LD	E, A		; A -> E

	LD	A, D		; D -> A
	SLA	A
	SLA	A
	SLA	A
	SLA	A
	AND	0F0h		; mask output data
	AND	E		; mask output data	
	LD      D, A		; masked output data -> D

	LD	A, E		; E -> A
	XOR	0FFh		; invert mask
	OR	0Fh		; set low bits to 1
	LD	E, A		; A -> E

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; i/o address -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; mask previous output data
	OR	D		; merge bytes
	LD	(DATOUT), A	; store data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- SWITCH ON A RCO PORT ------------------------------------------------------
; Input:     A = function code  (38h)
;            E = port number    (00-03h)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F38:
	LD	A, 1		; starting place value
	LD	B, E		; E -> B, shift counter
	INC	B		; correction
    
_LO38:
	DEC	B		; if B = 0
	JR	Z, _DO38	; - the goto _DO38 label
	SLA	A		; - else shift to left
    	JR	_LO38		;   goto _LO38 label

_DO38:
	RLCA			; shift: D0-D3 -> D4-D7
	RLCA
	RLCA
	RLCA
	LD	D, A		; A -> D

	XOR	0FFh		; invert place value
	OR	0Fh		; protect lower 4 bits
	LD	E, A		; A -> E (byte punch mask)

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; punch specified place valC)
	OR	D		; put 1 to hole
	
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write out data
	SCF			;  set Carry Flag
	JP	DONE

; --- SWITCH OFF A RCO PORT ------------------
; Input:     A = function code  (39h)
;            E = port number    (00-03h)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F39:
	LD	A, 1		; starting place value
	LD	B, E		; E -> B, shift counter
	INC	B		; correction
    
_LO39:
	DEC	B		; if B = 0
	JR	Z, _DO39	; - the goto _DO39 label
	SLA	A		; - else shift to left
    	JR	_LO39		;   goto _LO39 label

_DO39:
	RLCA			; shift: D0-D3 -> D4-D7
	RLCA
	RLCA
	RLCA
	LD	D, A		; A -> D

	XOR	0FFh		; invert place value
	OR	0Fh		; protect lower 4 bits
	LD	E, A		; A -> E (byte punch mask)

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; punch specified place valC)
	
	LD	(DATOUT), A	; store output data
	OUT	(C), A		; write out data
	SCF			;  set Carry Flag
	JP	DONE

; --- SWITCH ON AND DELAYED OFF A RCO PORT ---
; Input:     A = function code  (3Ah)
;            D = relative delay (00-FFh)
;            E = port number    (00-03h)
; Output:    A = 0
;            Carry = 1 (no valid return value)
F3A:
	LD	A, 1		; starting place value
	LD	B, E		; E -> B, shift counter
	INC	B		; correction
    
_LO3A:
	DEC	B		; if B = 0
	JR	Z, _DO3A	; - the goto _DO3A label
	SLA	A		; - else shift to left
    	JR	_LO3A		;   goto _LO3A label

_DO3A:
	RLCA			; shift: D0-D3 -> D4-D7
	RLCA
	RLCA
	RLCA
	LD	H, A		; A -> H

	XOR	0FFh		; invert place value
	OR	0Fh		; protect lower 4 bits
	LD	E, A		; A -> E (byte punch mask)

	LD	A, (ADDR)	; retrieve i/o address
	LD	C, A		; A -> C
	LD	A, (DATOUT)	; retrieve previous output data
	AND	E		; punch specified place valC)
	OR	H		; put 1 to hole
	OUT	(C), A		; write out data

	PUSH	HL		; save registers
_OL3A:				; start of the outer loop
	LD	HL, 4000h	; inner loop counter
_IL3A:				; start of the inner loop
	NOP			; waste of time
	DEC	HL		; decrement counter
	LD	A, H		; H -> A
	OR	L		; if H OR L = 0 -> Z = 1
	JP	NZ, _IL3A	; end of the inner loop
	DEC	D		; decrement relative delay value
	JP	NZ, _OL3A	; end of the outer loop
	POP	HL		; restore registers

	LD	A, (DATOUT)	; retrieve previous output data
	OUT	(C), A		; write out data
	SCF			; set Carry Flag
	JP	DONE

; --- DATA AREA -----------------------------------------------
ADDR:	DB	0		; I/O address
DATINP:	DB	0		; last data read from the port
DATOUT:	DB	0		; last data written to the port
	END

